<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), clipboard-write=(), display-capture=()">
    <title>UX Research Helper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            background-color: #f9fafb;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        .screen {
            display: none;
            height: calc(100vh - 60px);
            overflow-y: auto;
        }

        .screen.active {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            margin: 20px;
        }

        .tool-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin: 8px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        .method-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin: 8px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid #3b82f6;
        }

        .method-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        .question-card {
            background: #f8fafc;
            border-left: 4px solid #3b82f6;
            padding: 16px;
            margin: 8px 0;
            border-radius: 4px;
        }

        .status-item {
            background: white;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid;
        }

        .status-item:hover {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .status-gaps {
            border-left-color: #ef4444;
        }

        .status-followups {
            border-left-color: #f59e0b;
        }

        .status-design {
            border-left-color: #8b5cf6;
        }

        .status-save {
            border-left-color: #10b981;
        }

        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid #e5e7eb;
            padding: 12px 16px;
            z-index: 100;
        }

        .logo {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>

<body class="bg-gray-50">
    <!-- Header -->
    <div class="bg-white shadow-sm border-b">
        <div class="px-4 py-3 flex items-center justify-between">
            <div class="flex items-center space-x-3">
                <div class="logo">UX</div>
                <h1 class="text-lg font-semibold text-gray-900">UX Research Helper</h1>
            </div>
            <div class="flex items-center space-x-2">
                <span id="editor-type" class="text-xs text-gray-500 bg-blue-100 px-2 py-1 rounded">Figma</span>
                <span class="text-sm text-gray-500 bg-gray-100 px-2 py-1 rounded">V1</span>
            </div>
        </div>
    </div>

    <!-- Landing Screen -->
    <div id="landing-screen" class="screen active">
        <div class="p-4">
            <!-- Welcome Message -->
            <div class="text-center mb-6">
                <h2 class="text-xl font-semibold text-gray-900 mb-2">Welcome to UX Research Helper</h2>
                <p class="text-gray-600">Systematic UX research powered by Cursor AI. Choose a tool to begin your
                    research journey.</p>
            </div>

            <!-- Tools List -->
            <div class="mb-4">
                <h3 class="text-md font-medium text-gray-900 mb-3">Available Tools</h3>
                <div class="tool-card" onclick="selectTool('ux-research')">
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="font-medium text-gray-900">UX Research</h4>
                            <p class="text-sm text-gray-600">Comprehensive user experience research and problem
                                discovery</p>
                        </div>
                        <div class="text-blue-600">→</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- UX Research Tool Selection Screen -->
    <div id="ux-research-screen" class="screen">
        <div class="p-4">
            <!-- Header -->
            <div class="flex items-center mb-4">
                <button onclick="showScreen('landing-screen')" class="text-gray-500 hover:text-gray-700 mr-3">←
                    Back</button>
                <h2 class="text-lg font-semibold text-gray-900">UX Research</h2>
            </div>

            <!-- Tool Description -->
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                <h3 class="font-medium text-blue-900 mb-2">About UX Research</h3>
                <p class="text-sm text-blue-800">Systematic approach to understanding user needs, problems, and context
                    through structured research methods.</p>
            </div>

            <!-- Research Methods -->
            <div class="mb-4">
                <h3 class="text-md font-medium text-gray-900 mb-3">Available Research Methods</h3>
                <div class="method-card" onclick="selectMethod('problem-finder')">
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="font-medium text-gray-900">Problem Finder</h4>
                            <p class="text-sm text-gray-600">Comprehensive problem discovery across user, problem, and
                                context dimensions</p>
                        </div>
                        <div class="text-blue-600">→</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Research Flow Screen -->
    <div id="research-screen" class="screen">
        <div class="p-4">
            <!-- Header -->
            <div class="flex items-center justify-between mb-4">
                <div class="flex items-center">
                    <button onclick="showScreen('ux-research-screen')" class="text-gray-500 hover:text-gray-700 mr-3">←
                        Back</button>
                    <h2 class="text-lg font-semibold text-gray-900" id="research-title">Problem Finder Research</h2>
                </div>
                <span id="research-status" class="px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded-full">In
                    Progress</span>
            </div>

            <!-- Progress -->
            <div class="mb-4">
                <div class="flex justify-between text-sm text-gray-600 mb-1">
                    <span id="current-phase">User Dimension</span>
                    <span id="progress-text">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                    <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300"
                        style="width: 0%"></div>
                </div>
            </div>

            <!-- Current Question -->
            <div id="question-container" class="question-card">
                <h3 class="font-medium text-gray-900 mb-2" id="question-title">Q1: Who are the primary users
                    experiencing issues with this design?</h3>
                <p class="text-sm text-gray-600 mb-3" id="question-phase">Phase: User Dimension</p>
                <div id="question-options" class="space-y-2">
                    <!-- Options will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Fixed Footer -->
    <div class="footer">
        <div class="flex items-center justify-between">
            <div class="flex space-x-2">
                <div class="status-item status-gaps" onclick="showStatusModal('gaps')">
                    <span class="text-xs text-gray-600">Gaps</span>
                    <span class="text-sm font-medium text-gray-900" id="gaps-count">0</span>
                </div>
                <div class="status-item status-followups" onclick="showStatusModal('followups')">
                    <span class="text-xs text-gray-600">Follow-ups</span>
                    <span class="text-sm font-medium text-gray-900" id="followups-count">0</span>
                </div>
                <div class="status-item status-design" onclick="showStatusModal('design')">
                    <span class="text-xs text-gray-600">Design Discussion</span>
                    <span class="text-sm font-medium text-gray-900" id="design-count">0</span>
                </div>
            </div>
            <button onclick="saveResearch()" class="status-item status-save">
                <span class="text-xs text-gray-600">Save for Later</span>
            </button>
        </div>
    </div>

    <!-- Status Modals -->
    <div id="status-modal" class="modal">
        <div class="modal-content">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900" id="modal-title">Status Details</h3>
                <button onclick="closeStatusModal()" class="text-gray-500 hover:text-gray-700">✕</button>
            </div>
            <div id="modal-content">
                <!-- Modal content will be populated dynamically -->
            </div>
            <div class="mt-4 pt-4 border-t">
                <button onclick="closeStatusModal()"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors">
                    Continue Research
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentScreen = 'landing-screen';
        let currentResearch = {
            method: null,
            phase: null,
            questions: [],
            insights: [],
            actionItems: [],
            gaps: [],
            followups: [],
            designDiscussions: [],
            progress: 0,
            currentQuestionIndex: 0
        };

        // Screen navigation
        function showScreen(screenId) {
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });

            // Show target screen
            document.getElementById(screenId).classList.add('active');
            currentScreen = screenId;
        }

        // Tool selection
        function selectTool(toolId) {
            if (toolId === 'ux-research') {
                showScreen('ux-research-screen');
            }
        }

        // Method selection
        async function selectMethod(methodId) {
            if (methodId === 'problem-finder') {
                await startProblemFinderResearch();
            }
        }

        // Start Problem Finder research
        async function startProblemFinderResearch() {
            try {
                console.log('Starting Problem Finder research...');

                // Load instructions
                const instructions = await loadInstructions('UX Research - Problem Finder.md');
                console.log('Instructions loaded:', instructions);

                // Initialize research
                currentResearch.method = 'problem-finder';
                currentResearch.phase = 'User Dimension';
                currentResearch.currentQuestionIndex = 0;
                console.log('Research initialized');

                // Generate first question using AI
                console.log('Generating first AI question...');
                const firstQuestion = await generateAIQuestion('User Dimension', null, getFigmaContext());
                console.log('First question generated:', firstQuestion);

                currentResearch.questions = [firstQuestion];

                // Show research screen
                showScreen('research-screen');
                console.log('Research screen shown');

                // Start first question
                displayCurrentQuestion();
                console.log('Current question displayed');

                // Update status
                updateResearchStatus('In Progress', 0);
                console.log('Research started successfully');

            } catch (error) {
                console.error('Error starting research:', error);
                alert('Failed to start research. Please try again.');
            }
        }

        // Load instructions (using embedded instructions)
        async function loadInstructions(filename) {
            try {
                // Use embedded instructions instead of fetching files
                const instructions = getEmbeddedInstructions(filename);
                return parseInstructions(instructions);
            } catch (error) {
                console.error('Error loading instructions:', error);
                // Return fallback instructions if parsing fails
                return getFallbackInstructions();
            }
        }

        // Parse instructions from markdown
        function parseInstructions(text) {
            const instructions = {
                phases: [],
                questions: [],
                completionCriteria: []
            };

            // Extract phases
            const phaseMatches = text.match(/### Phase \d+: ([^\n]+)[\s\S]*?Questions:([\s\S]*?)(?=### Phase|\*\*Completion Criteria|\*\*Research Techniques|$)/g);
            if (phaseMatches) {
                phaseMatches.forEach(match => {
                    const phaseNameMatch = match.match(/### Phase \d+: ([^\n]+)/);
                    const questionsTextMatch = match.match(/Questions:([\s\S]*?)(?=\*\*Completion Criteria|\*\*Research Techniques|$)/);

                    const phaseName = phaseNameMatch && phaseNameMatch[1] ? phaseNameMatch[1].trim() : null;
                    const questionsText = questionsTextMatch && questionsTextMatch[1] ? questionsTextMatch[1] : null;

                    if (phaseName && questionsText) {
                        const questions = questionsText.split('\n')
                            .filter(line => line.trim().match(/^\d+\./))
                            .map(line => line.replace(/^\d+\.\s*/, '').trim())
                            .filter(q => q.length > 0);

                        instructions.phases.push({
                            name: phaseName,
                            questions: questions
                        });
                    }
                });
            }

            return instructions;
        }

        // Get embedded instructions
        function getEmbeddedInstructions(filename) {
            const instructions = {
                'UX Research - Problem Finder.md': `# UX Research - Problem Finder Instructions

## Research Method Overview
Comprehensive problem discovery framework that explores problems from multiple dimensions.

## Research Phases
### Phase 1: User Dimension
**Purpose:** Understand who experiences this problem
**Questions:**
1. Who are the primary users experiencing issues with this design?
2. What is their role and context when using this design?
3. How do different user types vary in their needs?
4. What are the edge cases or secondary users?

### Phase 2: Problem Dimension
**Purpose:** Define what's wrong and why
**Questions:**
1. What specific problems are these users experiencing?
2. Why does this problem exist? (root cause analysis)
3. How big is this problem? (impact assessment)
4. What's the scope of this problem?

### Phase 3: Context Dimension
**Purpose:** Understand the environment and constraints
**Questions:**
1. How do things work today in the current workflow?
2. What technical constraints limit our solutions?
3. What business requirements must be met?
4. How will we measure success?`
            };

            return instructions[filename] || '';
        }

        // Fallback instructions if parsing fails
        function getFallbackInstructions() {
            return {
                phases: [
                    {
                        name: 'User Dimension',
                        questions: [
                            'Who are the primary users experiencing issues with this design?',
                            'What is their role and context when using this design?',
                            'How do different user types vary in their needs?',
                            'What are the edge cases or secondary users?'
                        ]
                    },
                    {
                        name: 'Problem Dimension',
                        questions: [
                            'What specific problems are these users experiencing?',
                            'Why does this problem exist? (root cause analysis)',
                            'How big is this problem? (impact assessment)',
                            'What\'s the scope of this problem?'
                        ]
                    },
                    {
                        name: 'Context Dimension',
                        questions: [
                            'How do things work today in the current workflow?',
                            'What technical constraints limit our solutions?',
                            'What business requirements must be met?',
                            'How will we measure success?'
                        ]
                    }
                ]
            };
        }

        // Generate initial questions using AI
        async function generateInitialQuestions(instructions) {
            try {
                // Generate first question using AI
                const firstQuestion = await generateAIQuestion('User Dimension', null, null);
                return [firstQuestion];
            } catch (error) {
                console.error('Error generating AI questions:', error);
                // Fallback to first hardcoded question
                return [{
                    id: 'Q1',
                    text: 'Who are the primary users experiencing issues with this design?',
                    phase: 'User Dimension',
                    options: generateQuestionOptions('Who are the primary users experiencing issues with this design?'),
                    answered: false,
                    answer: null,
                    timestamp: new Date().toISOString()
                }];
            }
        }

        // Generate AI-powered question
        async function generateAIQuestion(phase, previousAnswer, context) {
            try {
                const prompt = `
                Generate a UX research question for the Problem Finder methodology.
                
                Current Phase: ${phase}
                Previous Answer: ${previousAnswer || 'None - this is the first question'}
                Figma Context: ${JSON.stringify(context || {})}
                
                Generate ONE focused question that:
                1. Follows the Problem Finder methodology
                2. Is appropriate for the current phase
                3. Builds on previous answers if available
                4. Considers the Figma design context
                
                Also provide 4 answer options for the question.
                
                Format your response as JSON:
                {
                    "question": "Your generated question here",
                    "options": ["Option 1", "Option 2", "Option 3", "Custom Response"],
                    "reasoning": "Why this question is important for this phase"
                }
                `;

                // Send to parent (Figma plugin) for AI processing
                return new Promise((resolve, reject) => {
                    const messageId = `generate_question_${Date.now()}`;

                    // Set up listener for AI response
                    const handleMessage = (event) => {
                        console.log('Received message in generateAIQuestion:', event.data);
                        if (event.data.pluginMessage && event.data.pluginMessage.type === 'ai-question-generated' && event.data.pluginMessage.data.messageId === messageId) {
                            console.log('AI question response received:', event.data.pluginMessage.data);
                            window.removeEventListener('message', handleMessage);

                            // Check if there's an error
                            if (event.data.pluginMessage.data.error) {
                                reject(new Error(event.data.pluginMessage.data.error));
                                return;
                            }

                            const aiResponse = event.data.pluginMessage.data.data;
                            if (!aiResponse) {
                                reject(new Error('No data received from AI'));
                                return;
                            }

                            const question = {
                                id: `Q${currentResearch.questions.length + 1}`,
                                text: aiResponse.question,
                                phase: phase,
                                options: aiResponse.options,
                                reasoning: aiResponse.reasoning,
                                answered: false,
                                answer: null,
                                timestamp: new Date().toISOString()
                            };

                            resolve(question);
                        }
                    };

                    window.addEventListener('message', handleMessage);

                    // Send request to plugin
                    parent.postMessage({
                        pluginMessage: {
                            type: 'generate-question',
                            messageId: messageId,
                            prompt: prompt,
                            phase: phase,
                            previousAnswer: previousAnswer,
                            context: context
                        }
                    }, '*');

                    // Timeout after 30 seconds (increased from 10)
                    setTimeout(() => {
                        console.log('AI question generation timeout for messageId:', messageId);
                        window.removeEventListener('message', handleMessage);
                        reject(new Error('AI question generation timeout'));
                    }, 30000);
                });

            } catch (error) {
                console.error('Error generating AI question:', error);
                // Show user-friendly error message
                if (error.message.includes('timeout')) {
                    throw new Error('AI is taking too long to respond. Please try again.');
                } else if (error.message.includes('fetch')) {
                    throw new Error('Unable to connect to AI service. Please check your internet connection.');
                } else {
                    throw new Error('Failed to generate question. Please try again.');
                }
            }
        }

        // Generate options for questions
        function generateQuestionOptions(questionText) {
            // This would be enhanced with AI-generated options
            const commonOptions = [
                'End users of the product',
                'Internal team members',
                'Administrators or managers',
                'Custom response'
            ];

            return commonOptions;
        }

        // Display current question
        function displayCurrentQuestion() {
            const question = currentResearch.questions[currentResearch.currentQuestionIndex];
            if (!question) return;

            document.getElementById('question-title').textContent = `${question.id}: ${question.text}`;
            document.getElementById('question-phase').textContent = `Phase: ${question.phase}`;

            // Update current phase
            document.getElementById('current-phase').textContent = question.phase;

            // Generate options
            const optionsContainer = document.getElementById('question-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const optionElement = document.createElement('button');
                optionElement.className = 'w-full text-left p-3 bg-white hover:bg-gray-50 rounded border transition-colors';
                optionElement.textContent = `${index + 1}) ${option}`;
                optionElement.onclick = () => selectOption(index, question.id);
                optionsContainer.appendChild(optionElement);
            });
        }

        // Select option
        async function selectOption(optionIndex, questionId) {
            const question = currentResearch.questions.find(q => q.id === questionId);
            if (!question) return;

            // Record the answer
            question.answer = question.options[optionIndex];
            question.answered = true;
            question.answeredAt = new Date().toISOString();

            // Process with AI
            await processAnswerWithAI(question);

            // Generate next question dynamically
            try {
                const nextPhase = determineNextPhase(question.phase);
                const nextQuestion = await generateAIQuestion(nextPhase, question.answer, getFigmaContext());

                // Add the new question
                currentResearch.questions.push(nextQuestion);
                currentResearch.currentQuestionIndex++;

                // Display the new question
                displayCurrentQuestion();
                updateProgress();

            } catch (error) {
                console.error('Error generating next question:', error);
                // Research complete if we can't generate more questions
                completeResearch();
            }
        }

        // Determine next phase based on current phase
        function determineNextPhase(currentPhase) {
            const phaseFlow = {
                'User Dimension': 'Problem Dimension',
                'Problem Dimension': 'Context Dimension',
                'Context Dimension': 'Analysis Phase'
            };
            return phaseFlow[currentPhase] || 'Analysis Phase';
        }

        // Get Figma context for AI
        function getFigmaContext() {
            return {
                selectedNodes: currentResearch.figmaContext ? currentResearch.figmaContext.selectedNodes : [],
                currentPage: currentResearch.figmaContext ? currentResearch.figmaContext.currentPage : null,
                projectInfo: currentResearch.figmaContext ? currentResearch.figmaContext.projectInfo : null
            };
        }

        // Process answer with AI
        async function processAnswerWithAI(question) {
            try {
                const prompt = `
                Analyze this UX research answer:
                
                Question: ${question.text}
                Answer: ${question.answer}
                Phase: ${question.phase}
                
                Provide insights in JSON format:
                {
                    "insights": ["insight1", "insight2"],
                    "followUpQuestions": ["question1", "question2"],
                    "designImplications": ["implication1", "implication2"],
                    "assumptions": ["assumption1", "assumption2"]
                }
                `;

                // Send to parent (Figma plugin) for AI processing
                parent.postMessage({
                    pluginMessage: {
                        type: 'process-answer',
                        questionId: question.id,
                        answer: question.answer,
                        prompt: prompt
                    }
                }, '*');

            } catch (error) {
                console.error('Error processing with AI:', error);
            }
        }

        // Update progress
        function updateProgress() {
            const totalQuestions = currentResearch.questions.length;
            const answeredQuestions = currentResearch.questions.filter(q => q.answered).length;
            const progress = Math.round((answeredQuestions / totalQuestions) * 100);

            currentResearch.progress = progress;
            document.getElementById('progress-bar').style.width = `${progress}%`;
            document.getElementById('progress-text').textContent = `${progress}%`;
        }

        // Complete research
        function completeResearch() {
            document.getElementById('research-status').textContent = 'Complete';
            document.getElementById('research-status').className = 'px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full';

            // Show completion message
            document.getElementById('question-container').innerHTML = `
                <div class="text-center py-8">
                    <h3 class="text-lg font-semibold text-gray-900 mb-2">Research Complete!</h3>
                    <p class="text-gray-600 mb-4">You've completed the Problem Finder research.</p>
                    <div class="space-y-2">
                        <button onclick="exportResearch()" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors">
                            Export Research
                        </button>
                        <button onclick="showScreen('landing-screen')" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition-colors">
                            Start New Research
                        </button>
                    </div>
                </div>
            `;
        }

        // Status modal functions
        function showStatusModal(type) {
            const modal = document.getElementById('status-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');

            let title = '';
            let content = '';

            switch (type) {
                case 'gaps':
                    title = 'Research Gaps';
                    content = currentResearch.gaps.length > 0
                        ? currentResearch.gaps.map(gap => `<div class="p-2 bg-red-50 border-l-2 border-red-400 mb-2">${gap}</div>`).join('')
                        : '<p class="text-gray-500">No gaps identified yet.</p>';
                    break;
                case 'followups':
                    title = 'Follow-up Questions';
                    content = currentResearch.followups.length > 0
                        ? currentResearch.followups.map(followup => `<div class="p-2 bg-yellow-50 border-l-2 border-yellow-400 mb-2">${followup}</div>`).join('')
                        : '<p class="text-gray-500">No follow-up questions yet.</p>';
                    break;
                case 'design':
                    title = 'Design Discussions';
                    content = currentResearch.designDiscussions.length > 0
                        ? currentResearch.designDiscussions.map(discussion => `<div class="p-2 bg-purple-50 border-l-2 border-purple-400 mb-2">${discussion}</div>`).join('')
                        : '<p class="text-gray-500">No design discussions yet.</p>';
                    break;
            }

            modalTitle.textContent = title;
            modalContent.innerHTML = content;
            modal.classList.add('active');
        }

        function closeStatusModal() {
            document.getElementById('status-modal').classList.remove('active');
        }

        // Save research
        function saveResearch() {
            parent.postMessage({
                pluginMessage: {
                    type: 'save-research',
                    data: currentResearch
                }
            }, '*');

            alert('Research saved successfully!');
        }

        // Export research
        function exportResearch() {
            const exportData = {
                method: currentResearch.method,
                phase: currentResearch.phase,
                questions: currentResearch.questions,
                insights: currentResearch.insights,
                actionItems: currentResearch.actionItems,
                gaps: currentResearch.gaps,
                followups: currentResearch.followups,
                designDiscussions: currentResearch.designDiscussions,
                progress: currentResearch.progress,
                currentQuestionIndex: currentResearch.currentQuestionIndex,
                exportedAt: new Date().toISOString(),
                version: '1.0'
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `ux-research-${Date.now()}.json`;
            link.click();
        }

        // Update research status
        function updateResearchStatus(status, progress) {
            document.getElementById('research-status').textContent = status;
            document.getElementById('progress-bar').style.width = `${progress}%`;
            document.getElementById('progress-text').textContent = `${progress}%`;
        }

        // Listen for messages from parent (Figma plugin)
        window.addEventListener('message', (event) => {
            if (event.data.pluginMessage) {
                const message = event.data.pluginMessage;

                switch (message.type) {
                    case 'answer-processed':
                        // Update research artifacts
                        if (message.data.aiResponse) {
                            const aiResponse = message.data.aiResponse;
                            if (aiResponse.insights) {
                                currentResearch.insights = currentResearch.insights.concat(aiResponse.insights);
                            }
                            if (aiResponse.followUpQuestions) {
                                currentResearch.followups = currentResearch.followups.concat(aiResponse.followUpQuestions);
                            }
                            if (aiResponse.designImplications) {
                                currentResearch.designDiscussions = currentResearch.designDiscussions.concat(aiResponse.designImplications);
                            }
                            if (aiResponse.assumptions) {
                                currentResearch.gaps = currentResearch.gaps.concat(aiResponse.assumptions);
                            }
                        }

                        // Update status counts
                        updateStatusCounts();
                        break;

                    case 'editor-type':
                        // Update editor type display
                        const editorTypeElement = document.getElementById('editor-type');
                        if (editorTypeElement) {
                            editorTypeElement.textContent = message.data.editorType === 'figjam' ? 'FigJam' : 'Figma';
                            editorTypeElement.className = message.data.editorType === 'figjam'
                                ? 'text-xs text-gray-500 bg-green-100 px-2 py-1 rounded'
                                : 'text-xs text-gray-500 bg-blue-100 px-2 py-1 rounded';
                        }
                        break;

                    case 'figma-context':
                        // Store Figma context for AI question generation
                        currentResearch.figmaContext = message.data;
                        console.log('Figma context received:', message.data);
                        break;
                }
            }
        });

        // Update status counts
        function updateStatusCounts() {
            document.getElementById('gaps-count').textContent = currentResearch.gaps.length;
            document.getElementById('followups-count').textContent = currentResearch.followups.length;
            document.getElementById('design-count').textContent = currentResearch.designDiscussions.length;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('UX Research Helper UI initialized');
            updateStatusCounts();

            // Request editor type from plugin
            parent.postMessage({
                pluginMessage: {
                    type: 'get-editor-type'
                }
            }, '*');

            // Request Figma context from plugin
            parent.postMessage({
                pluginMessage: {
                    type: 'get-figma-context'
                }
            }, '*');
        });
    </script>
</body>

</html>